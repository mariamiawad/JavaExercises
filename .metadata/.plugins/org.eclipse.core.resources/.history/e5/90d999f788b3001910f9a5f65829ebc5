
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.channels.NonWritableChannelException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.IllegalFormatCodePointException;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;

public class RunningMedian {
	 
	static Comparator<Object> maxHeapComparator = new Comparator<Object>() {

		@Override
		public int compare(Object arg0, Object arg1) {
			if (((Integer) arg0).compareTo((Integer) arg1)>0) {
				return 1;
			}
			else if (( (Integer) arg0).compareTo((Integer) arg1)<0) {
				return -1;
			}
			return 0;
		}
	};
	static Comparator<Object> minHeapComparator = new Comparator<Object>() {

		@Override
		public int compare(Object arg0, Object arg1) {
			if (((Integer) arg0).compareTo((Integer) arg1)<0) {
				return 1;
			}
			else if (((Integer) arg0).compareTo((Integer) arg1)>0) {
				return -1;
			}
			return 0;
		}
	};
	static PriorityQueue<Object> maxQueue = new PriorityQueue<Object>(maxHeapComparator);
	static PriorityQueue<Object> minQueue = new PriorityQueue<Object>(minHeapComparator);

	public static double MaxHeap(Object[] array) {
		Integer[] a;
		for (int i = 0; i < array.length; i++) {
			a = new Integer[array.length]; 
			a[i] = (Integer) array[i];
			maxQueue.add(a[i]);
		}
		Integer  b = (Integer) maxQueue.peek();
		return   Double.valueOf(b.toString());
		

	}

	public static double MinimumHeap(Object[] array) {

		
		Integer[] a;
		for (int i = 0; i < array.length; i++) {
			a = new Integer[array.length]; 
			a[i] = (Integer) array[i];
			minQueue.add(a[i]);
		}
		Integer b = (Integer) minQueue.peek();
		return Double.valueOf(b.toString());
				}
//		else {
//			tempArray = new int[(array.length / 2)+1];
//
//			tempArray = Arrays.copyOfRange(array, 0, (array.length+1)/2+1);
//			for (int i = 0; i < (array.length / 2) - 1; i++) {
//				queue.add(tempArray[i]);
//
//			}
//			double temp = MaxHeap(tempArray);
//			return temp;

	public static void getMedian(Object[] array) {
		Double min = Double.valueOf(0.0);
		Double max = Double.valueOf(0.0);;
		if(array.length == 1) {
			minQueue.add(array[0]);
			min =Double.parseDouble(minQueue.peek().toString()); 
		}
		else if(((int) array[array.length-1]>= (double)minQueue.peek() && Math.abs(minQueue.size()-maxQueue.size())<=1)) {
			 min =Double.parseDouble(minQueue.peek().toString());
		}
		 else if ((int)array[array.length-1]< (double)minQueue.peek()&& Math.abs(minQueue.size()-maxQueue.size())<=1) {
			 max = Double.parseDouble(maxQueue.peek().toString());
		}
		
		if(Math.abs(minQueue.size() -maxQueue.size())>1) {
			if(minQueue.size()> maxQueue.size()) {
			maxQueue.add(minQueue.peek());
			minQueue.remove();
			}
			else {
				minQueue.add(maxQueue.peek());
				maxQueue.remove();
			}
		}
		if(!(minQueue.size()%2==0)&& minQueue.size()>maxQueue.size()) {
			System.out.println(min);
		}
		else  { 
		System.out.println((max+min/2.0));
		}
		
//		else {
//			int [] tempArray = new int [array.length];
//			tempArray = Arrays.copyOfRange(array,0,(new BigDecimal(array.length/2.0).setScale(0, RoundingMode.CEILING).intValue()));
//			double max = MaxHeap(array);
//			tempArray = Arrays.copyOfRange(array, (new BigDecimal(array.length/2.0).setScale(1, RoundingMode.HALF_UP).intValue()), array.length);
//			double min = MinimumHeap(array);
//			System.out.println(min);
//		}
//		
		

	}

	public static boolean isOdd(int[] array) {
		int count = 0;
		for (int i = 0; i < array.length; i++) {
			count++;
		}
		if (count % 2 != 0) {
			return true;
		}
		return false;

	}

	private static final Scanner scanner = new Scanner(System.in);

	public static void main(String[] args) {
		int n = scanner.nextInt();
		scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

		int[] a = new int[n];
		
		for (int i = 0; i < n; i++) {
			int aItem = scanner.nextInt();
			scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");
			a[i] = aItem;
			Integer[] array = new Integer[i+1];
			Integer[] temp = Arrays.stream( a ).boxed().toArray( Integer[]::new );
			array = Arrays.copyOfRange(temp, 0, i+1);
			
			getMedian(array);
			

		}
		scanner.close();
	}
}
