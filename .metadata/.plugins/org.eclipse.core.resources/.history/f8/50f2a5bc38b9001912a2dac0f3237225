import java.io.*;
import java.math.*;
import java.security.*;
import java.text.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.Spliterator.OfInt;
import java.util.concurrent.*;
import java.util.function.*;
import java.util.regex.*;
import java.util.stream.*;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

//class Result {
//
//    /*
//     * Complete the 'shop' function below.
//     *
//     * The function is expected to return an INTEGER.
//     * The function accepts following parameters:
//     *  1. INTEGER n
//     *  2. INTEGER k
//     *  3. STRING_ARRAY centers
//     *  4. 2D_INTEGER_ARRAY roads
//     */



//}
public class SychronousShopping {

    public static int shop(int n, int k, List<String> centers, List<List<Integer>> roads) {
    	List<String[]> list = centers.stream().map(String -> String.split(" ")).collect(Collectors.toList());
    	     
//     	List<String>strings =((Collection<String>) list.iterator()).stream().map(Collections::replaceAll).spliterator().trySplit();(Spliterator->toList());
//     			.split(" ", ",").map(String::trim).map(Integer::parseInt).collect(Collectors.toList());
//    	Spliterator<String> liSpliterator = list.forEach(1);
//                .map(List<String>::forEach).collect(Collectors.toList());
//    	List<Integer> longIds = 
//    			((List<Integer>)objlList.stream().map(Integer::valueOf).convertAll(
//    		        Splitter.on(' ').trimResults().omitEmptyStrings());
////		.collect(Collectors.toList());
//   ( newList).stream().map(Integer::valueOf).collect(Collectors.toList());
    	
    	Map<Integer, Integer> mapOfFish = new HashMap<Integer, Integer>();
    	int numberOfFishType = 0;
    	int numberOfType = 0;
    	for (String s : centers) {
			
			mapOfFish.put(Integer.parseInt(s), numberOfFishType);
			
			
		}
    	Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		map.put(roads.get(0).get(0), 0);
		
    	for (int i = 1; i < n -1; i++) {
    		int min= Integer.MAX_VALUE;
    		int selectedNode = 0;
    		for (int j = 0; j < roads.size(); j++) {
    			if(map.containsKey(roads.get(j).get(0))||map.containsKey(roads.get(j).get(1))) {
    				if(roads.get(j).get(2)<=min) {
    					min = roads.get(j).get(2);
    					if(map.containsKey(roads.get(j).get(0))){
    						selectedNode = roads.get(j).get(0);
    						
    					}
    				}
    			}
    					else {
							selectedNode = roads.get(j).get(1);
						}
    				
    			
    			map.put(selectedNode, roads.get(j).get(2));
    		}
		}
    	int sum = 0;
    	for (Entry<Integer, Integer>entry: map.entrySet()) {
			sum += entry.getValue();
		}
		return sum;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
//        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String[] firstMultipleInput = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");

        int n = Integer.parseInt(firstMultipleInput[0]);

        int m = Integer.parseInt(firstMultipleInput[1]);

        int k = Integer.parseInt(firstMultipleInput[2]);

        List<String> centers = IntStream.range(0, n).mapToObj(i -> {
            try {
                return bufferedReader.readLine();
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .collect(toList());

        List<List<Integer>> roads = new ArrayList<>();

        IntStream.range(0, m).forEach(i -> {
            try {
                roads.add(
                    Stream.of(bufferedReader.readLine().replaceAll("\\s+$", "").split(" "))
                        .map(Integer::parseInt)
                        .collect(toList())
                );
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        });

        int res = shop(n, k, centers, roads);
System.out.println(res);
//        bufferedWriter.write(String.valueOf(res));
//        bufferedWriter.newLine();

        bufferedReader.close();
//        bufferedWriter.close();
    }
}
