import java.io.*;
import java.math.*;
import java.security.*;
import java.text.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.*;
import java.util.function.*;
import java.util.regex.*;
import java.util.stream.*;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

class Stringss {
	// starts from 0. 
    
      
       
    // dp[2^10][101] .. in dp[i][j], i denotes the mask i.e., it tells that 
    // how many and which persons are wearing cap. j denotes the first j caps 
    // used. So, dp[i][j] tells the number ways we assign j caps to mask i 
    // such that none of them wears the same cap 
    static int dp[][] = new int[1025][101]; 
       
    // This is used for base case, it has all the N bits set 
    // so, it tells whether all N persons are wearing a cap. 
    static int allmask; 
    static final int MOD = 1000000007; 
    static long countWaysUtil(int mask, int i) 
    {  mask = 2;
        // If all persons are wearing a cap so we 
        // are done and this is one way so return 1 
        if (mask == allmask) return 1; 
       
        // If not everyone is wearing a cap and also there are no more 
        // caps left to process, so there is no way, thus return 0; 
        if (i > 100) return 0; 
       
        // If we already have solved this subproblem, return the answer. 
        if (dp[mask][i] != -1) return dp[mask][i]; 
       
        // Ways, when we don't include this cap in our arrangement 
        // or solution set. 
        long ways = countWaysUtil(mask, i+1); 
       
        // size is the total number of persons having cap with id i. 
        int size = capList[i].size(); 
       
        // So, assign one by one ith cap to all the possible persons 
        // and recur for remaining caps. 
        for (int j = 0; j < size; j++) 
        { 
            // if person capList[i][j] is already wearing a cap so continue as 
            // we cannot assign him this cap 
            if ((mask & (1 << capList[i].get(j))) != 0) continue; 
       
            // Else assign him this cap and recur for remaining caps with 
            // new updated mask vector 
            else ways += countWaysUtil(mask | (1 << capList[i].get(j)), i+1); 
            ways %= MOD; 
        } 
       
        // Save the result and return it. 
        return dp[mask][i] = (int) ways; 
    }
    // Driver method 


    public static int shop(int n, int k, List<String> centers, List<List<Integer>> roads) {
    	  String str; 
          List<String[]> split; 
          int x; 
            Vector<Integer> capList[] = new Vector[centers.size()];
          for ( int i=0; i<n; i++) 
          { 
               
              split = centers.stream().map(List -> List.split(" ")).collect(Collectors.toList()); 
              
              // while there are words in the split[] 
              for (int j = 0; j < split.size(); j++) { 
                   for (String[] strings : split) {
  					str = strings[j];
  					x = Integer.parseInt(str); 
  	                capList[x].add(i); 

  				}
                              } 
              
          } 
    	  int mask = n;
          // If all persons are wearing a cap so we 
          // are done and this is one way so return 1 
          if (mask == allmask) return 1; 
         int i=0;
          // If not everyone is wearing a cap and also there are no more 
          // caps left to process, so there is no way, thus return 0; 
          if (i > centers.size()) return 0; 
         
          // If we already have solved this subproblem, return the answer. 
          if (dp[mask][i] != -1) return dp[mask][i]; 
         
          // Ways, when we don't include this cap in our arrangement 
          // or solution set. 
          long ways = countWaysUtil(mask, i+1); 
         
          // size is the total number of persons having cap with id i. 
          int size = centers.get(i).length(); 
         
          // So, assign one by one ith cap to all the possible persons 
          // and recur for remaining caps. 
          for (int j = 0; j < size; j++) 
          { 
              // if person capList[i][j] is already wearing a cap so continue as 
              // we cannot assign him this cap 
              if ((mask & (1 << centers.get(i))) != 0) continue; 
         
              // Else assign him this cap and recur for remaining caps with 
              // new updated mask vector 
              else ways += countWaysUtil(mask | (1 << capList[i].get(j)), i+1); 
              ways %= MOD; 
          } 
         
          // Save the result and return it. 
          return dp[mask][i] = (int) ways; 
      
    	
    	
    	
    	
}

public class SychronousShopping {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
//        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String[] firstMultipleInput = bufferedReader.readLine().replaceAll("\\s+$", "").split(" ");

        int n = Integer.parseInt(firstMultipleInput[0]);

        int m = Integer.parseInt(firstMultipleInput[1]);

        int k = Integer.parseInt(firstMultipleInput[2]);

        List<String> centers = IntStream.range(0, n).mapToObj(i -> {
            try {
                return bufferedReader.readLine();
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .collect(toList());

        List<List<Integer>> roads = new ArrayList<>();

        IntStream.range(0, m).forEach(i -> {
            try {
                roads.add(
                    Stream.of(bufferedReader.readLine().replaceAll("\\s+$", "").split(" "))
                        .map(Integer::parseInt)
                        .collect(toList())
                );
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        });

        int res = Stringss.shop(n, k, centers, roads);
System.out.println(res);
//        bufferedWriter.write(String.valueOf(res));
//        bufferedWriter.newLine();

        bufferedReader.close();
//        bufferedWriter.close();
    }
}
